IGMP DEFINITIONS ::= BEGIN
    EXPORTS PDU;
    PDU_IGMP ^ PDU ::= (V3Report | Query | V2Report | V2Leave) < transfer >
        Callback
    </ transfer >

    Query_IGMP ^ Query ::= SEQUENCE {
        type_Query_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_Query_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_Query_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_Query_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES),
        v3Add_Query_IGMP ^ v3Add V3Addition (SIZE DEFINED) OPTIONAL
    } < transfer >
        Back {type == 17}
        Forward {EXISTS (v3Add) == PDUREMAINING}
    </ transfer >

    V3Addition_IGMP ^ V3Addition ::= SEQUENCE {
        resvSQRV_V3Addition_IGMP ^ resvSQRV INTEGER (SIZE 1 BYTES),
        QQIC_V3Addition_IGMP ^ QQIC INTEGER (SIZE 1 BYTES),
        numSources_V3Addition_IGMP ^ numSources INTEGER (SIZE 2 BYTES),
        srcAddrs_V3Addition_IGMP ^ srcAddrs SET OF SOURCEADDRESS (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Forward {CARDINALITY (srcAddrs) == numSources}
    </ transfer >

    V2Report_IGMP ^ V2Report ::= SEQUENCE {
        type_V2Report_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_V2Report_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_V2Report_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_V2Report_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type == 22}
    </ transfer >

    V2Leave_IGMP ^ V2Leave ::= SEQUENCE {
        type_V2Leave_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_V2Leave_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_V2Leave_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_V2Leave_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type == 23}
    </ transfer >

    V3Report_IGMP ^ V3Report ::= SEQUENCE {
        type_V3Report_IGMP ^ type INTEGER (SIZE 1 BYTES),
        reserved_V3Report_IGMP ^ reserved INTEGER (SIZE 1 BYTES),
        checksum_V3Report_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        secondReserved_V3Report_IGMP ^ secondReserved INTEGER (SIZE 2 BYTES),
        numGrps_V3Report_IGMP ^ numGrps INTEGER (SIZE 2 BYTES),
        groupRecordInfo_V3Report_IGMP ^ groupRecordInfo SET OF GROUPRECORD (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type == 34}
        Forward {CARDINALITY (groupRecordInfo) == numGrps}
    </ transfer >

    GROUPRECORD_IGMP ^ GROUPRECORD ::= SEQUENCE {
        recordType_GROUPRECORD_IGMP ^ recordType INTEGER (SIZE 1 BYTES),
        auxDataLen_GROUPRECORD_IGMP ^ auxDataLen INTEGER (SIZE 1 BYTES),
        numSources_GROUPRECORD_IGMP ^ numSources INTEGER (SIZE 2 BYTES),
        groupAddr_GROUPRECORD_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES),
        srcAddrs_GROUPRECORD_IGMP ^ srcAddrs SET OF SOURCEADDRESS (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Forward {CARDINALITY (srcAddrs) == numSources}
    </ transfer >

    SOURCEADDRESS_IGMP ^ SOURCEADDRESS ::= SEQUENCE {
        srcAddr_SOURCEADDRESS_IGMP ^ srcAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)

END
