IGMP DEFINITIONS ::= BEGIN
    EXPORTS PDU_IGMP ^ PDU;
    PDU_IGMP ^ PDU ::= (V3Report_IGMP | Query_IGMP | V2Report_IGMP | V2Leave_IGMP) < transfer >
        Callback
    </ transfer >

    Query_IGMP ^ Query ::= SEQUENCE {
        type_Query_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_Query_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_Query_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_Query_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES),
        v3Add_Query_IGMP ^ v3Add V3Addition_IGMP (SIZE DEFINED) OPTIONAL
    } < transfer >
        Back {type_Query_IGMP == 17}
        Forward {EXISTS (v3Add_Query_IGMP) == PDUREMAINING}
    </ transfer >

    V3Addition_IGMP ^ V3Addition ::= SEQUENCE {
        resvSQRV_V3Addition_IGMP ^ resvSQRV INTEGER (SIZE 1 BYTES),
        QQIC_V3Addition_IGMP ^ QQIC INTEGER (SIZE 1 BYTES),
        numSources_V3Addition_IGMP ^ numSources INTEGER (SIZE 2 BYTES),
        srcAddrs_V3Addition_IGMP ^ srcAddrs SET OF SOURCEADDRESS_IGMP (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Forward {CARDINALITY (srcAddrs_V3Addition_IGMP) == numSources_V3Addition_IGMP}
    </ transfer >

    V2Report_IGMP ^ V2Report ::= SEQUENCE {
        type_V2Report_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_V2Report_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_V2Report_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_V2Report_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type_V2Report_IGMP == 22}
    </ transfer >

    V2Leave_IGMP ^ V2Leave ::= SEQUENCE {
        type_V2Leave_IGMP ^ type INTEGER (SIZE 1 BYTES),
        maxRespTime_V2Leave_IGMP ^ maxRespTime INTEGER (SIZE 1 BYTES),
        checksum_V2Leave_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        groupAddr_V2Leave_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type_V2Leave_IGMP == 23}
    </ transfer >

    V3Report_IGMP ^ V3Report ::= SEQUENCE {
        type_V3Report_IGMP ^ type INTEGER (SIZE 1 BYTES),
        reserved_V3Report_IGMP ^ reserved INTEGER (SIZE 1 BYTES),
        checksum_V3Report_IGMP ^ checksum INTEGER (SIZE 2 BYTES),
        secondReserved_V3Report_IGMP ^ secondReserved INTEGER (SIZE 2 BYTES),
        numGrps_V3Report_IGMP ^ numGrps INTEGER (SIZE 2 BYTES),
        groupRecordInfo_V3Report_IGMP ^ groupRecordInfo SET OF GROUPRECORD_IGMP (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Back {type_V3Report_IGMP == 34}
        Forward {CARDINALITY (groupRecordInfo_V3Report_IGMP) == numGrps_V3Report_IGMP}
    </ transfer >

    GROUPRECORD_IGMP ^ GROUPRECORD ::= SEQUENCE {
        recordType_GROUPRECORD_IGMP ^ recordType INTEGER (SIZE 1 BYTES),
        auxDataLen_GROUPRECORD_IGMP ^ auxDataLen INTEGER (SIZE 1 BYTES),
        numSources_GROUPRECORD_IGMP ^ numSources INTEGER (SIZE 2 BYTES),
        groupAddr_GROUPRECORD_IGMP ^ groupAddr INTEGER (SIZE 4 BYTES),
        srcAddrs_GROUPRECORD_IGMP ^ srcAddrs SET OF SOURCEADDRESS_IGMP (SIZE CONSTRAINED)
    } (ENCODED BY CUSTOM)
    < transfer >
        Forward {CARDINALITY (srcAddrs_GROUPRECORD_IGMP) == numSources_GROUPRECORD_IGMP}
    </ transfer >

    SOURCEADDRESS_IGMP ^ SOURCEADDRESS ::= SEQUENCE {
        srcAddr_SOURCEADDRESS_IGMP ^ srcAddr INTEGER (SIZE 4 BYTES)
    } (ENCODED BY CUSTOM)

END
